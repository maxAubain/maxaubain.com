{
  "header": {
    "date": {
      "post": "Feb. 26, 2020",
      "update": ""
    },
    "title": {
      "main": "Webpack - a utility for managing front end static assets",
      "subtitle": "A review of functionality and value added"
    },
    "image": {
      "src": "img/webpack-logo.png",
      "alt": "webpack-logo"
    }
  },
  "body": [
    {
      "paragraph": "Webpack [1] is an essential library used in the Node ecosystem, and integral with the optimizing and 'packaging' of static assets in the front end.  The library is a utility -- as in, it has various, but separate, uses throughout the application.  The value of its multiple functions are dependent on the context in which they are used, much like the various 'blades' of Swiss Army Knife are useful in opening cardboard boxes, filing nails, or unfastening a screw."
    },
    {
      "quote": "The value of [Webpack's] multiple functions are dependent on the context in which they are used, much like the various 'blades' of a Swiss Army Knife are useful in opening cardboard boxes, filing nails, or unfastening a screw."
    },
    {
      "paragraph": "The two contexts which drive the configuration of Webpack are how the developer plans to use it in 1) development mode or 2) production mode.  For example, an asset tree can be exported for review in a development build, which can help track and troubleshoot the location and hierarchy of assets.  However, exporting the asset tree in production could become a critical security vulnuerability.  In this short post, I will review some of Webpack's key features and explain the conditions in which they can become useful additions to your front end development and production flows."
    },
    {
      "divide": ""
    },
    {
      "paragraph": "While Webpack has many different types of tools, they all support static asset management.  What are static assets?  Fonts, stylesheets, images, pdfs, even React components... any file, element, or structure in the webpage DOM that is not expected to mutate once loaded on the webpage; a front end (connected to a REST API) is comprised of these static assets. The default configuration of a webpage is to load the static assets in the order in which they 'hit' the browser, which can lead to long or messy-looking page loads -- a true eyesore and sure way to lose the visitor's confidence.  The key concept to keep in mind when thinking about how to use Webpack is that it lets the developer customize the grouping of assets so that they are rendered in memory efficient and user friendly ways."
    },
    {
      "paragraph": "In the flow diagram labeled 'Unbundled' below, a schematic example is shown of how a generic, single-page React app might be configured.  The javascript code of the React library instantiation and its components are imported from `index.js`, to be served to the browser with `index.html`.  `app.jsx` is referenced within `index.js`, with the former importing all of the required assets for a terse professional website.  Notice the types of assets that are loaded to `app.jsx`: Sass CSS files; React components; and a PDF.  One can assume there are also dependencies between files, for example between `profile.jsx` and `profile.scss`.  Without further configuration the imports are run asynchronosly, which means everything loads to the DOM in parallel and, well, each element renders when it's ready with no order or plan!"
    },
    {
      "image": {
        "src": "img/unbundled.png",
        "alt": "unbundled-app",
        "width": "300px",
        "caption": "All assets are asynchronously loaded according to their internal dependencies and individual files sizes by default."
      }
    },
    {
      "paragraph": "From a production perspective, Webpack offers improved webpage load times through 'bundling' and 'minimization' [2, 3].  Bundling checks dependencies between assets to enable ordered loading, and removes dependencies that are unused or redundant.  The bundled code is further minimized by removing characters and variables that exists but are, for whatever reason, not part of the code that actually gets executed, such as spaces and unused but declared variables.  The file size reduction thanks to the minimization process standard in Webpack can be on the order of 30% to 40% [4]."
    },
    {
      "paragraph": "It is easy to integrate assets into bundles, which are recognized by file extension.  Many 'loader' plugins are available to process commonly used asset types, such as .pdf, .png, .js, .jsx, etc [5].  In the diagram below and the context of the preceding discussion, the `main.js` file is the bundle and the runtime.js is the autogenerated file to reference the bundle for execution into html."
    },
    {
      "image": {
        "src": "img/bundled.png",
        "alt": "bundled-app",
        "width": "300px",
        "caption": "Bundled assets load with an ordered flow and can be minimized to reduce data transfer time."
      }
    },
    {
      "paragraph": "As websites grow, it may become advantageous to 'code-split' [6] and divide the code base into multiple sections, or to 'lazy-load' [7] (in other words, postpone) the rendering of an element until right up to the point of viewing."
    },
    {
      "paragraph": "In the diagram below, the same front end assets as before have been reorganized to take advantage of these two features.  By code-splitting the application into `profile.js` and `portfolio.js` bundles, each element is saved separately in the browser cache.  If one element needs to be updated with a patch, and consequently re-downloaded by a user, only the patched bundle needs to be downloaded instead of the entire page.  Furthermore, we can say the `resume.pdf` file is 5mb and contained in the portfolio section.  5mb is very large for a browser element and could substantially increase page loading time, especially for internet connections with poor transfer speeds. We will want to lazy-load the pdf asset and allow the rest of the portfolio page to show first.  For completeness, it is also important to note that Webpack enables the 'preload' of assets [8] that have not yet been rendered, but are expected to with a change of state to the page."
    },
    {
      "image": {
        "src": "img/codesplit.png",
        "alt": "codesplit-app",
        "width": "300px",
        "caption": "Codesplitting and lazy-loading further 'chunk' the code to make sure each section is loaded optimially for the best user experience."
      }
    },
    {
      "divide": ""
    },
    {
      "paragraph": "On the development mode side of using Webpack, I have found a number of tools that greatly improve my quality of life as a developer.  As a first example, as the patterns used to delay or accelerate asset loading gets complex, sometimes it is useful to perform a 'bundle analysis' [9] to monitor bundle file sizes as shown in the example below."
    },
    {
      "image": {
        "src": "img/bundle-list.png",
        "alt": "bundle-list",
        "width": "100%",
        "caption": "I have bundled the Node modules for caching optimization, but have yet to optimize my main application (as Webpack warns with '[big]'!)."
      }
    },
    {
      "paragraph": "Secondly, Webpack also provides a development server that can 'hot' load [10] a React app, such that any changes to the code sensed by the development server, in real time, will reflect in the browser without having to reload the browser or restart the server.  It is hard to understate the convenience of this feature!"
    },
    {
      "paragraph": "A third feature I found useful lies on the DevOps side, in my situation where the bundle file names become auto-generated with hashes or dates.  Each bundle must be included in `index.html` via a script tag, like any javascript file, but it becomes impossibly time-consuming to add each bundle manually after a new build.  Luckily, the Webpack community is active and skilled, and so a quick setup of the HtmlWebpackPlugin [11] generates the html file with all of the needed header and script tags, and the CleanWebpackPlugin [12] removes outdated bundles."
    },
    {
      "paragraph": "In conclusion, Webpack is a mature, well maintained JS library that can help manage front end assets.  If you would like to see an example of how many of these features are implemented in a React single-page app, please visit my github page [13]."
    }
  ],
  "footnotes": [
    {
      "number": 1,
      "text": "Media (e.g. images, logos, brand names, etc.) and statements referencing webpack (TM) are intended for use in this post in accordance with OpenJS policies.",
      "url": "https://openjsf.org/wp-content/uploads/sites/84/2019/10/OpenJS-Foundation-Trademark-Policy-2019-10-22.pdf"
    },
    {
      "number": 2,
      "text": "Webpack: build performance.",
      "url": "https://webpack.js.org/guides/getting-started/"
    },
    {
      "number": 3,
      "text": "Webpack: output management.",
      "url": "https://webpack.js.org/guides/output-management/"
    },
    {
      "number": 4,
      "text": "Using webpack to split optimized assets into chunks for faster browser reload.",
      "url": "https://medium.com/hackernoon/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758"
    },
    {
      "number": 5,
      "text": "Webpack: build performance.",
      "url": "https://webpack.js.org/guides/build-performance/"
    },
    {
      "number": 6,
      "text": "Webpack: code splitting.",
      "url": "https://webpack.js.org/guides/code-splitting/"
    },
    {
      "number": 7,
      "text": "Webpack: lazy loading.",
      "url": "https://webpack.js.org/guides/lazy-loading/"
    },
    {
      "number": 8,
      "text": "Webpack: preloading.",
      "url": "https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules"
    },
    {
      "number": 9,
      "text": "Webpack: bundle analysis.",
      "url": "https://webpack.js.org/guides/code-splitting/#bundle-analysis"
    },
    {
      "number": 10,
      "text": "Webpack: hot module replacement.",
      "url": "https://webpack.js.org/concepts/hot-module-replacement/"
    },
    {
      "number": 11,
      "text": "Webpack: auto-generate html file plugin.",
      "url": "https://webpack.js.org/plugins/html-webpack-plugin/"
    },
    {
      "number": 12,
      "text": "Github: /dist folder cleaner plugin for webpack.",
      "url": "https://github.com/johnagan/clean-webpack-plugin"
    },
    {
      "number": 13,
      "text": "Github: example of Webpack configuration file for this website.",
      "url": "https://github.com/maxAubain/maxaubain.com/blob/master/webpack.config.js"
    }
  ]
}
